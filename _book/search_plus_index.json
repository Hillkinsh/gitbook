{"./":{"url":"./","title":"简单的概述","keywords":"","body":"读书和做笔记 如何阅读一本书 从一个进入学校认识第一个拼音字母开始，我已经读了25年书了。但很偶然间看到一本书告诉你，读书的学问，说实话很是震惊。但该书良好的口碑和对各行各业的人带来的深刻影响促使我很有兴趣的买来读一读。 读书的过程中，最大的感触就是边度边点头称妙。像比如作者推崇的，略读、主动阅读，带着问题阅读等，其实都知道，并且一般都会遵循。但这本书将一整套读书的思路和方法总结下来，非常系统。真的是对阅读的思路做了一个完整的重塑。大赞。 本内容的第一部分将循着书本《如何阅读一本书》的脉略对该书的核心内容作出梳理。 做笔记 在第二部分，我放置的是一些前端开发实践中，遇到问题的总结。总结有两个目的，第一肯定是深度整理问题及背后的知识，第二则是后续如果有需要时也能迅速的翻阅。 ©hillkinsham@gmail.com all right reserved，powered by Gitbook文档更新时间： 2021-03-11 11:04:50 "},"如何阅读一本书/1.阅读的目标.html":{"url":"如何阅读一本书/1.阅读的目标.html","title":"如何阅读一本书","keywords":"","body":"如何阅读一本书 阅读的目标分为两类： 为获得资讯而读 为求得理解而读 第一种意义是我们在阅读报纸、杂志等，凭借我们的阅读技巧与聪明才智，一下子便能融会贯通了。这样的读书能增加我们的资讯却不能增进我们的理解力。因为在开始阅读之前，我们的理解力就已经和作者相当了，否则我们一路读下来早就被困住了或者吓住了 而第二种阅读是一个人试着读某样他一开始不理解的东西。这个东西的水平就是比读者高出一截。这个作者想要表达的东西能增进阅读者的理解力。 ©hillkinsham@gmail.com all right reserved，powered by Gitbook文档更新时间： 2021-03-11 11:07:57 "},"chapter1/2.阅读的层次.html":{"url":"chapter1/2.阅读的层次.html","title":"阅读的四个层次","keywords":"","body":"阅读的四个层次 本书的核心内容就是在阐释阅读的四个层次分别是什么 第一层 基础阅读 能看懂字，能读懂句，能看懂段落和段 第二层 检视阅读 检视阅读就是对一本书的一个大致印象。比如花个十分钟，对书的书名作者简介、序言以及大概的书的章节在说什么，并随便翻开几节读一读。就是只粗略的读一遍，弄懂书的架构和要讨论的主题。 第三层 分析阅读 全盘的完整的阅读，能够根据自己所读的东西提出很多问题。并能够一一认证求解的阅读。 第四层 主题阅读 做主题阅读时，阅读的已经不是一本书，而是很多书，能列举出书之间的关联，提出所有书都提出的一个主题。 ©hillkinsham@gmail.com all right reserved，powered by Gitbook文档更新时间： 2021-01-31 15:42:00 "},"chapter1/3.基础阅读.html":{"url":"chapter1/3.基础阅读.html","title":"第一层：基础阅读","keywords":"","body":"每一个正常的reader都是合格的。 ©hillkinsham@gmail.com all right reserved，powered by Gitbook文档更新时间： 2021-01-31 15:44:21 "},"chapter1/4.检视阅读.html":{"url":"chapter1/4.检视阅读.html","title":"第二层：检视阅读","keywords":"","body":"检视阅读 检视阅读分为两种：1。有系统的略读或粗读；2.粗浅的阅读。我理解两个是为同一个目标服务的。但既然区分开，还是存在一些基本的差异。 略读 先看书名页，有序就先看序。 研究目录页，对书的架构做一个基本了解。 阅读书中的索引，可以快速的评估本书涵盖的议题。 读出版者的介绍， 挑几个和主题相关的篇章看看 随便翻翻书，读个几段。 粗浅的阅读 把书从头到尾的读一遍，遇到不懂的地方不要查询和思索 ©hillkinsham@gmail.com all right reserved，powered by Gitbook文档更新时间： 2021-01-31 16:20:22 "},"chapter1/5.学会提问.html":{"url":"chapter1/5.学会提问.html","title":"第三层pre：学会提问","keywords":"","body":"第三层pre：学会提问 这一章节的表述是如何做一个自我要求的读者。我根据内容的重要性，挑出最重要的一个议题。但展开时会将本章的完整概括写下 关于一本书，你一定要提出的四个主要问题： 这本书在谈什么，即找到书的主题 作者细部说了什么怎么说的，即是主要的想法、声明和论点。 本书有道理吗，全部有道理还是部分有道理。 这本书跟你有什么关系。 如何让一本书属于自己 答案：做笔记，去写。 写的意义（或者好处）： 保持清醒 主动阅读，其实是一种思考，而思考倾向于语言表达 将阅读时的感想写下来，帮助自己记得作者的思想 如何做笔记 关键句子划线。做编号。 在书的空白处做笔记，可以在书前面的空白页在自己读完后将读书的大纲写下来。 ©hillkinsham@gmail.com all right reserved，powered by Gitbook文档更新时间： 2021-01-31 16:35:05 "},"chapter2/1.第三层:分析阅读.html":{"url":"chapter2/1.第三层:分析阅读.html","title":"Chapter2","keywords":"","body":"Chapter2 之所以把分析阅读，这一层单独独立出来，是基于分析阅读的重要性来说的。分析阅读的技巧关乎能否吃透一本书。也是读书的目的实现的关键。 ©hillkinsham@gmail.com all right reserved，powered by Gitbook文档更新时间： 2021-02-01 22:30:18 "},"chapter2/2.书籍的分类.html":{"url":"chapter2/2.书籍的分类.html","title":"书籍的分类","keywords":"","body":"Section1.1 论说性的书 书的主要内容有一些观点、理论、假设，推断等所组成，并且作者多少表示了主张是有依据的，有道理的，那这种书就是论说性的书。 理论性和实用性作品 论说性的书一个基本分类原则就是分为理论性和实用性； 理论性的作品是在教你这是什么， 实用性作品则教你如何去做你想做到的事情 理论性作品的分类 历史，科学，哲学等。 科学和哲学的区分： 如果一本理论书所强调的内容超乎日常、例行、正常生活的经验，那就是科学的书；否则就是哲学的书。 科学家会从他特殊的结果做举证，哲学家会以人类的共通性做例证。 聊这些东西，其实是铺垫分析阅读的第一个规则： 你一定要知道自己在读的是那一类书，而且越早知道越好。 ©hillkinsham@gmail.com all right reserved，powered by Gitbook文档更新时间： 2021-02-01 22:30:18 "},"chapter2/3.透视一本书.html":{"url":"chapter2/3.透视一本书.html","title":"透视一本书","keywords":"","body":"透视一本书 分析阅读的第一阶段，找出一本书在谈什么的四个规则： 依照书本的种类与主题分类； 用最简单的句子说出整本书在谈些什么； 按照顺序关系列出全书的重要部分。 找出作者在问的问题，或作者想要解决的问题。 第二阶段的四个阅读规则： 找出共同的词义 （找出重要的单词，透过他们与作者达成共识） 将一本书最重要的句子圈出来，找出其中的主旨。 从相关文句的关联中，设法架构一本书的基本论述。 找出作者的解答。确定作者已经解决了哪些问题，还有那些是未解决的。在未解决的问题中，确定哪些是作者认为无法解决的。 ©hillkinsham@gmail.com all right reserved，powered by Gitbook文档更新时间： 2021-02-02 22:28:45 "},"chapter2/4.评价一本书.html":{"url":"chapter2/4.评价一本书.html","title":"评价一本书","keywords":"","body":"评价一本书 批评式阅读的三个规则 先读完完整的书，而不要急于批评； 不要争强好胜和盲目反对； 将知识上的不同意见看作是大体可以解决的问题。 ©hillkinsham@gmail.com all right reserved，powered by Gitbook文档更新时间： 2021-02-02 22:32:29 "},"chapter3/1.egg中间件.html":{"url":"chapter3/1.egg中间件.html","title":"技术总结","keywords":"","body":"技术总结 从请求压缩的需求来讨论一下egg中间件该如何开发 正常的网络相应时，如果对相应内容做了gzip压缩，那么无疑将大大减小相应体的体积，那么针对这个问题，可以考虑实现一个中间件。 中间件的位置和配置 egg中，约定中间件的放置目录是app/middleware，中间件是exports的一个普通函数，其接受两个参数： options： 配置项，框架会将app.config[${middlewareName}]传递进来。 app：当前应用的实例。 比如：我们写 // app/middleware/gzip.js const isJSON = require('koa-is-json'); const zlib = require('zlib'); module.exports = options => { return async function gzip(ctx, next) { await next(); // 后续中间件执行完成后将响应体转换成 gzip let body = ctx.body; if (!body) return; // 支持 options.threshold if (options.threshold && ctx.length 使用 使用中间件，需要我们手动挂载，支持以下的几种方式： 应用中使用 // config/config.default.js module.exports = appInfo => { const config = {}; config.middleware = [ 'gzip' ]; config.gzip = { threshold: 1024, // 小于 1k 的响应体不压缩 } } 该配置最终将在启动时合并到 app.config.appMiddleware。 在框架和插件中使用中间件 // app.js module.exports = app => { // 在中间件最前面统计请求时间 app.config.coreMiddleware.unshift('report'); }; // app/middleware/report.js module.exports = () => { return async function (ctx, next) { const startTime = Date.now(); await next(); // 上报请求时间 reportTime(Date.now() - startTime); } }; 应用层定义的中间件（app.config.appMiddleware）和框架默认中间件（app.config.coreMiddleware）都会被加载器加载，并挂载到 app.middleware 上。 router中使用中间件 以上两种方式配置的中间件是全局的，会处理每一次请求。 如果你只想针对单个路由生效，可以直接在 app/router.js 中实例化和挂载，如下： module.exports = app => { const gzip = app.middleware.gzip({ threshold: 1024 }); app.router.get('/needgzip', gzip, app.controller.handler); }; 框架默认的中间件 除了应用层加载中间件之外，框架自身和其他的插件也会加载许多中间件。所有的这些自带中间件的配置项都通过在配置中修改中间件同名配置项进行修改，例如框架自带的中间件中有一个 bodyParser 中间件（框架的加载器会将文件名中的各种分隔符都修改成驼峰形式的变量名），我们想要修改 bodyParser 的配置，只需要在 config/config.default.js 中编写 module.exports = { bodyParser: { jsonLimit: '10mb', }, }; 注意：框架和插件加载的中间件会在应用层配置的中间件之前，框架默认中间件不能被应用层中间件覆盖，如果应用层有自定义同名中间件，在启动时会报错。 使用 Koa 的中间件 在框架里面可以非常容易的引入 Koa 中间件生态。 以 koa-compress 为例，在 Koa 中使用时： const koa = require('koa'); const compress = require('koa-compress'); const app = koa(); const options = { threshold: 2048 }; app.use(compress(options)); 我们按照框架的规范来在应用中加载这个 Koa 的中间件： // app/middleware/compress.js // koa-compress 暴露的接口(`(options) => middleware`)和框架对中间件要求一致 module.exports = require('koa-compress'); // config/config.default.js module.exports = { middleware: [ 'compress' ], compress: { threshold: 2048, }, }; 通用配置 无论是应用层加载的中间件还是框架自带中间件，都支持几个通用的配置项： enable：控制中间件是否开启。 match：设置只有符合某些规则的请求才会经过这个中间件。 ignore：设置符合某些规则的请求不经过这个中间件。 enable 如果我们的应用并不需要默认的 bodyParser 中间件来进行请求体的解析，此时我们可以通过配置 enable 为 false 来关闭它 module.exports = { bodyParser: { enable: false, }, }; match 和 ignore match 和 ignore 支持的参数都一样，只是作用完全相反，match 和 ignore 不允许同时配置。 如果我们想让 gzip 只针对 /static 前缀开头的 url 请求开启，我们可以配置 match 选项 module.exports = { gzip: { match: '/static', }, }; match 和 ignore 支持多种类型的配置方式 字符串：当参数为字符串类型时，配置的是一个 url 的路径前缀，所有以配置的字符串作为前缀的 url 都会匹配上。 当然，你也可以直接使用字符串数组。 正则：当参数为正则时，直接匹配满足正则验证的 url 的路径。 函数：当参数为一个函数时，会将请求上下文传递给这个函数，最终取函数返回的结果（true/false）来判断是否匹配。module.exports = { gzip: { match(ctx) { // 只有 ios 设备才开启 const reg = /iphone|ipad|ipod/i; return reg.test(ctx.get('user-agent')); }, }, }; ©hillkinsham@gmail.com all right reserved，powered by Gitbook文档更新时间： 2021-02-18 18:01:01 "},"chapter3/2.取消ajax请求.html":{"url":"chapter3/2.取消ajax请求.html","title":"取消ajax请求","keywords":"","body":"取消ajax请求 当密集请求时，我们往往需要以最后一次的请求结果为准，那么此时就需要前面做的网络请求取消掉。不然有可能会造成，后一次请求结果先于前一次的，导致展示内容不是想要的。 原生 调用本次实例的abort方法 var native = new XMLHttpRequest(); native.open(\"GET\",\"https://api.github.com/\"); native.send(); native.onreadystatechange=function(){ if(native.readyState==4&&native.status==200){ console.log(native.response); }else{ console.log(native.status); } } native.abort(); jq jQuery为我们封装了ajax请求接口，在jQuery中，取消ajax请求也是通过调用.abort()方法，只不过操作的对象不再是原生XHR对象。 取消ajax之后，jQuery封装的ajax对象就会执行error对应的函数 j var jp = $.ajax({ type:\"get\", url:\"https://api.github.com/\", dataType:\"json\", success:function(data){ console.log(data); }, error:function(err){ console.log(err); } }) jp.abort(); axios 如果我们经常使用axios发送ajax请求。在axios中取消ajax请求不同于上面两种形式，在axios中是通过axios.CancelToken.source()方法取消请求 var CancelToken = axios.CancelToken; var source = CancelToken.source(); axios({ method:\"GET\", url:\"https://api.github.com/\", cancelToken:source.token //cancelToken的值起标识作用，标识由source控制的、将要被取消的ajax操作 }).then((res) => { console.log(res.data); }).catch((err) => { console.log(err); }); source.cancel('Operation canceled by the user.'); ©hillkinsham@gmail.com all right reserved，powered by Gitbook文档更新时间： 2021-03-11 10:57:22 "}}